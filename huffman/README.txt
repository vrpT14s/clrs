2023-08-08
Proof of huffman code greedy choice property:
Say we have an optimal tree where the highest frequency member is not the highest leaf. Then we find the most frequent member and switch it with the highest leaf. Huffman trees are not binary trees or heaps, they don't have to obey any property at the nodes. Thus we get a totally valid huffman tree. Now this new tree has a lower average transmission length than the previous tree, by (length_1 - length_2)(freq_2 - freq_1) where 2 is supposed to be the most frequent leaf and 1 is the highest (in the previous tree). Proof of this is that the sum before is sum freq*length, so difference since the other leaves are the same is f1*l2 + f2*l1 - f1*f1 - f2*f2 = what I said before (whoops I got the minus wrong, the newer one should have a minus overall, i'm calculating the increase (which is negative), not the decrease). Clearly this is positive and non-zero, so we have contradicted ourselves when we said the previous tree was optimum.

We can play the same game with nodes instead of just leaves. Say the highest frequency node is not the highest node. The expected value is sum f_k l_k, and grouping under the node, the other leaves stay the same except for the two nodes. The sum can be expressed as F_n*L_i + sum f_i*l_i where the l_i's are the relative lengths for a single node and F_i is the sum of all the freq's of the leaves under the node. Thus we express it this way for two nodes and no others, then if we switch them the deccrease will be F1*L1 + F2*L2 - F1*L2 - F2*L1 = (F1 - F2)*(L1 - L2). Both of these are negative so the total is positive, so there's a decrease, thus contradiction.

Thus for the optimal tree, its two subnodes must be the top two highest frequency subnodes, or else we could swap them with something else to cause a non zero decrease in average transmission length. The DMP version of this program
